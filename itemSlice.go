package amiibo

import (
	"fmt"

	"github.com/gellel/slice"
)

var (
	_ itemSlice = (*ItemSlice)(nil)
)

// getItemSlice returns a new Item slice pointer using the argument bytes as the initial entries.
// Assumes the argument byte slice pointer contains valid Item slice information that can be
// marshalled to Item struct. Should byte slice point hold incorrect or malformed values
// Go will panic. The byte slice pointer can be generated by using a Amiibo content fetching
// function.
func getItemSlice(content *[]byte) *ItemSlice {
	rawPayload, err := unmarshallRawPayload(content)
	if err != nil {
		panic(err)
	}
	itemSlice := newItemSlice()
	for _, rawMessage := range rawPayload.Items {
		r := newRawItem(rawMessage)
		a := newItem(r)
		itemSlice.Append(a)
	}
	return itemSlice
}

// newItemSlice instantiates a new Item slice pointer.
func newItemSlice() *ItemSlice {
	return &ItemSlice{slice: &slice.Slice{}}
}

// itemSlice defines the interface for an Item slice pointer.
type itemSlice interface {
	Append(item *Item) *ItemSlice
	Assign(item ...*Item) *ItemSlice
	Bounds(i int) bool
	Concatenate(itemSlice *ItemSlice) *ItemSlice
	Each(f func(i int, item *Item)) *ItemSlice
	Empty() bool
	Fetch(i int) *Item
	Get(i int) (*Item, bool)
	Len() int
	Map(func(i int, item *Item) *Item) *ItemSlice
	Poll() *Item
	Pop() *Item
	Preassign(item ...*Item) *ItemSlice
	Precatenate(itemSlice *ItemSlice) *ItemSlice
	Prepend(item *Item) *ItemSlice
	Push(item *Item) int
	Replace(i int, item *Item) bool
	Set() *ItemSlice
	Slice(start, end int) *ItemSlice
	Splice(start, end int) *ItemSlice
	String() string
}

// An ItemSlice is a slice-like struct whose methods are used to perform insertion, mutation and iteration operations on an
// unordered collection of Item pointers. Each Item slice can contain 0 to N number of normalized Items, with each
// Item pointer being held in a private slice field. All exposed methods for the Item slice perform a corresponding
// operation for this internal field. This property is protected to prevent incorrect data assignment as the slice permits
// any data interface to be assigned to the Item slice. For direct access to each Item struct pointer within
// the Item slice, a normal Go provided slice or array declaration should be used over the ItemSlice struct.
type ItemSlice struct {
	slice *slice.Slice
}

// Append adds a new Item struct pointer to the end of Item slice and returns the modified Item slice.
func (pointer *ItemSlice) Append(item *Item) *ItemSlice {
	pointer.slice.Append(item)
	return pointer
}

// Assign adds N Item struct pointers to the end Item slice and returns the modified Item slice.
func (pointer *ItemSlice) Assign(item ...*Item) *ItemSlice {
	for _, item := range item {
		pointer.Append(item)
	}
	return pointer
}

// Bounds checks an integer value safely sits within the range of accessible values for the Item slice.
func (pointer *ItemSlice) Bounds(i int) bool {
	return pointer.slice.Bounds(i)
}

// Concatenate merges two Item slices into a single Item slice.
func (pointer *ItemSlice) Concatenate(itemSlice *ItemSlice) *ItemSlice {
	pointer.slice.Concatenate(itemSlice.slice)
	return pointer
}

// Each executes a provided function once for each Item struct pointer in the Item slice in the same order in a for-each loop.
func (pointer *ItemSlice) Each(f func(i int, item *Item)) *ItemSlice {
	pointer.slice.Each(func(i int, value interface{}) {
		f(i, value.(*Item))
	})
	return pointer
}

// Empty returns a boolean indicating whether the Item slice contains zero values.
func (pointer *ItemSlice) Empty() bool {
	return pointer.slice.Empty()
}

// Fetch retrieves the Item pointer held at the argument index. Returns nil if index exceeds Item slice length.
func (pointer *ItemSlice) Fetch(i int) *Item {
	item, _ := pointer.Get(i)
	return item
}

// Get returns the Item pointer held at the argument index and a boolean indicating if it was successfully retrieved.
func (pointer *ItemSlice) Get(i int) (*Item, bool) {
	value, ok := pointer.slice.Get(i)
	if ok {
		return value.(*Item), ok
	}
	return nil, ok
}

// Len method returns the number of elements in the Item slice.
func (pointer *ItemSlice) Len() int {
	return pointer.slice.Len()
}

// Map method executes a provided function once for each Item pointer in the Item slice
// and sets the returned value to the current index.
func (pointer *ItemSlice) Map(f func(i int, item *Item) *Item) *ItemSlice {
	pointer.slice.Map(func(i int, value interface{}) interface{} {
		return f(i, value.(*Item))
	})
	return pointer
}

// Poll method removes the first element from the Item slice and returns that removed Item.
func (pointer *ItemSlice) Poll() *Item {
	value := pointer.slice.Poll()
	if value != nil {
		return value.(*Item)
	}
	return nil
}

// Pop method removes the last Item from the Item slice and returns that Item.
func (pointer *ItemSlice) Pop() *Item {
	value := pointer.slice.Pop()
	if value != nil {
		return value.(*Item)
	}
	return nil
}

// Preassign method adds zero or more Item pointers to the beginning of the Item slice and returns the modified Item slice.
func (pointer *ItemSlice) Preassign(item ...*Item) *ItemSlice {
	for _, item := range item {
		pointer.Prepend(item)
	}
	return pointer
}

// Precatenate merges two Item slices, prepending the argument Item slice to the beginning of the receiver Item slice.
func (pointer *ItemSlice) Precatenate(itemSlice *ItemSlice) *ItemSlice {
	pointer.slice.Precatenate(itemSlice.slice)
	return pointer
}

// Prepend method adds one Item to the beginning of the Item slice and returns the modified Item slice.
func (pointer *ItemSlice) Prepend(item *Item) *ItemSlice {
	pointer.slice.Prepend(item)
	return pointer
}

// Push method adds a new Item to the end of the Item slice and returns the length of the modified Item slice.
func (pointer *ItemSlice) Push(item *Item) int {
	return pointer.slice.Push(item)
}

// Replace method replaces the Item at the argument index if it is in bounds with the provided argument Item.
func (pointer *ItemSlice) Replace(i int, item *Item) bool {
	return pointer.slice.Replace(i, item)
}

// Set method returns a unique Item slice, removing duplicate Item pointers that have the same ID.
func (pointer *ItemSlice) Set() *ItemSlice {
	itemSlice := newItemSlice()
	m := map[string]bool{}
	pointer.Each(func(_ int, item *Item) {
		if _, ok := m[item.ID]; !ok {
			m[item.ID] = true
			itemSlice.Append(item)
		}
	})
	return itemSlice
}

func (pointer *ItemSlice) Slice(start, end int) *ItemSlice {
	return &ItemSlice{slice: pointer.slice.Slice(start, end)}
}

func (pointer *ItemSlice) Splice(start, end int) *ItemSlice {
	return &ItemSlice{slice: pointer.slice.Splice(start, end)}
}

func (pointer *ItemSlice) String() string {
	return fmt.Sprintf("%v", *pointer)
}
